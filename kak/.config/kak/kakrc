#colorscheme catppuccin_latte

# Lines numbers and relative numbers
add-highlighter global/ number-lines -relative

# Highlight matching pair
add-highlighter global/ show-matching

# Wrap on word boundaries
add-highlighter global/ wrap -indent -word

# Highlight trailing whitespace
add-highlighter global/ regex \h+$ 0:Error

set-option global scrolloff 5,5

map global normal <c-v> ":comment-line<ret>"

# System clipboard bindings
map global user y "<a-|>xsel -ib<ret>" -docstring "[Y]ank to system clipboard"
map global user p "|xsel -ob<ret>" -docstring "[P]ut from system clipboard"

map global user c -docstring "[C]ompile the current file" ":compile<ret>"
define-command -docstring "Compile the current document" compile %{
    nop %sh{ {
        compiler $"{kak_buffile}"
    } > /dev/null 2>&1 < /dev/null & }
}

hook global BufCreate .*\.[Rr]md %{ set-option buffer filetype markdown }

# Pattern for communicating with kak via it's session socket
define-command sockettest %{
    nop %sh{ {
        sleep 10
        echo "eval -client '$kak_client' 'echo sleep ended'" |
            kak -p ${kak_session}
    } > /dev/null 2>&1 < /dev/null & }
}

# Pattern for communicating with kak via it's session socket
define-command fzf_open %{
    nop %sh{ {
        sleep 10
        echo "eval -client '$kak_client' 'echo sleep ended'" |
            kak -p ${kak_session}
    } > /dev/null 2>&1 < /dev/null & }
}

define-command fifotest %{
    evaluate-commands %sh{
         # Create a temporary fifo for communication
         output=$(mktemp -d -t kak-temp-XXXXXXXX)/fifo
         mkfifo ${output}
         # run command detached from the shell
         { fzf > ${output} } > /dev/null 2>&1 < /dev/null &
         # Open the file in Kakoune and add a hook to remove the fifo
         echo "edit! -fifo ${output} *buffer-name*
               hook buffer BufClose .* %{ nop %sh{ rm -r $(dirname ${output})} }"
    }
}

define-command fzf %{edit %sh{fd -t f | fzf --tmux --preview 'highlight -O ansi {}'}}
map global user f -docstring "[F]ind a file (with fzf)" ":fzf<ret>"

# Trick to make compiler run async
#hook global BufWritePost .*\.(md|tex|ms)$ %{
#    nop %sh{ {
#        compiler $"{kak_buffile}"
#    } > /dev/null 2>&1 < /dev/null & }
#}
# Simpler version
# hook global BufWritePost .*\.(md|tex)$ %{
#     echo -debug %sh{compiler "${kak_buffile}"}
# }

# Filetypes with two-space indentation
hook global BufCreate .*\.(js|html|ts|tsx)$ %{
    set-option buffer indentwidth 2
}
# Filetypes with four-space indentation
hook global BufCreate .*\.(py)$ %{
    set-option buffer indentwidth 4
}


eval %sh{kak-lsp}
hook global WinSetOption filetype=(rust|python|go|javascript|typescript|c|cpp) %{
    lsp-enable-window
}

remove-hooks global lsp-filetype-python
hook -group lsp-filetype-python global BufSetOption filetype=python %{
    # set-option buffer lsp_servers %{
    #     [pylsp]
    #     root_globs = ["requirements.txt", "setup.py", "pyproject.toml", ".git", ".hg"]
    #     settings_section = "_"
    #     [pylsp.settings._]
    #     # See https://github.com/python-lsp/python-lsp-server#configuration
    #     # pylsp.configurationSources = ["flake8"]
    #     pylsp.plugins.jedi_completion.include_params = true
    # }
    set-option buffer lsp_servers %{
        [pyright-langserver]
        root_globs = ["requirements.txt", "setup.py", "pyproject.toml", "pyrightconfig.json", ".git", ".hg"]
        args = ["--stdio"]
    }
    # set-option -add buffer lsp_servers %{
    #     [ruff]
    #     args = ["server", "--quiet"]
    #     root_globs = ["requirements.txt", "setup.py", "pyproject.toml", ".git", ".hg"]
    #     settings_section = "_"
    #     [ruff.settings._.globalSettings]
    #     organizeImports = true
    #     fixAll = true
    # }
}

hook -group lsp-filetype-javascript global BufSetOption filetype=(?:javascript|typescript) %{
    set-option buffer lsp_servers %{
        [vtsls]
        root_globs = ["package.json", "tsconfig.json", "jsconfig.json", ".git", ".hg"]
        args = ["--stdio"]
        settings_section = "_"
        [vtsls.settings._]
        quotePreference = "single"
        # typescript.format.semicolons = "insert"
    }
    #set-option buffer lsp_servers %{
    #    [typescript-language-server]
    #    root_globs = ["package.json", "tsconfig.json", "jsconfig.json", ".git", ".hg"]
    #    args = ["--stdio"]
    #    settings_section = "_"
    #    [typescript-language-server.settings._]
    #    # quotePreference = "double"
    #    # typescript.format.semicolons = "insert"
    #}
    # set-option buffer lsp_servers %{
    #     [deno]
    #     root_globs = ["package.json", "tsconfig.json", ".git", ".hg"]
    #     args = ["lsp"]
    #     settings_section = "deno"
    #     [deno.settings.deno]
    #     enable = true
    #     lint = true
    # }
    # set-option buffer lsp_servers %opt{lsp_server_biome}
    # set-option buffer lsp_servers %{
    #     [eslint-language-server]
    #     root_globs = [".eslintrc", ".eslintrc.json"]
    #     args = ["--stdio"]
    #     workaround_eslint = true
    #     [eslint-language-server.settings]
    #     codeActionsOnSave = { mode = "all", "source.fixAll.eslint" = true }
    #     format = { enable = true }
    #     quiet = false
    #     rulesCustomizations = []
    #     run = "onType"
    #     validate = "on"
    #     experimental = {}
    #     problems = { shortenToSingleLine = false }
    #     codeAction.disableRuleComment = { enable = true, location = "separateLine" }
    #     codeAction.showDocumentation = { enable = false }
    # }
    # set-option buffer lsp_servers %{
    #     [tailwindcss-language-server]
    #     root_globs = ["tailwind.*"]
    #     args = ["--stdio"]
    #     [tailwindcss-language-server.settings.tailwindCSS]
    #     editor = {}
    # }
}

map global user l ':enter-user-mode lsp<ret>' -docstring 'LSP mode'

map global insert <tab> '<a-;>:try lsp-snippets-select-next-placeholders catch %{ execute-keys -with-hooks <lt>tab> }<ret>' -docstring 'Select next snippet placeholder'
map global user h ':lsp-hover<ret>' -docstring 'LSP hover'

map global object a '<a-semicolon>lsp-object<ret>' -docstring 'LSP any symbol'
map global object <a-a> '<a-semicolon>lsp-object<ret>' -docstring 'LSP any symbol'
map global object f '<a-semicolon>lsp-object Function Method<ret>' -docstring 'LSP function or method'
map global object t '<a-semicolon>lsp-object Class Interface Struct<ret>' -docstring 'LSP class interface or struct'
map global object d '<a-semicolon>lsp-diagnostic-object --include-warnings<ret>' -docstring 'LSP errors and warnings'
map global object D '<a-semicolon>lsp-diagnostic-object<ret>' -docstring 'LSP errors'
